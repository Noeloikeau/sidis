# AUTOGENERATED! DO NOT EDIT! File to edit: 01_conversion.ipynb (unless otherwise specified).

__all__ = ['data', 'types', '__cast', 'rules', 'cast_', 'isiter', 'iterables', 'numbers', 'typestr', 'cast', 'pad',
           'fillar', 'nbits', 'rint', 'RNG', 'num2ar', 'ar2num', 'ar2hex', 'hex2ar', 'str2ar', 'ar2str', 'COPY', 'NOT',
           'AND', 'OR', 'Exclusive_OR', 'XOR', 'ar2gr', 'gr2ar', 'num2gr', 'convert']

# Cell
import typing
import numpy as np
from typing import Optional, Tuple, Dict, Callable, Union, Mapping, Sequence, Iterable
from functools import partial
import warnings

# Cell
data = Union[int,float,list,tuple,str,dict,set,np.ndarray]
types={t:t for t in [int,float,list,tuple,str,dict,set,np.ndarray]}

# Cell
def __cast(to : data, obj : data) -> data:
    '''
    Typecasts `obj` to datatype `to`.
    First inner typecasting function.
    Fallback case of more complex casting behavior.
    '''
    try:
        return to(obj)
    except:
        return typing.cast(to,obj)

# Cell
rules={t:partial(__cast,t) for t in types}
rules[np.ndarray]=np.array #use the numpy function
rules[None]=lambda t:t #and return the object in case nothing given

# Cell
def cast_(obj : data,to : data) -> data:
    '''
    Second inner typecast function using global rulebook `rules`.
    '''
    global rules
    return rules[to](obj)

# Cell
isiter = lambda t: hasattr(t,'__iter__')
iterables=[t for t in types if isiter(t)]
numbers=[t for t in types if t not in iterables]

# Cell
def typestr(x : data):
    '''
    Parses the string of the input type for readability.
    '''
    if type(x) is type: #if passing type itself
        s=x
    else: #otherwise get type of obj
        s=type(x)
    return str(s).split('<')[-1].split('>')[0].split('class')[-1].split('\'')[1]

# Cell
def cast(obj : data, to : data = None) -> data:
    '''
    Universal typecasting function.
    Typecasts the `obj` to the desired datatype `to`,
    with support for wrapping of various types.
    '''
    t=type(obj)
    to_iter=isiter(to)
    in_iter=isiter(t)
    if to_iter==in_iter:
        return cast_(obj,to)
    elif isiter(t): #if it's an iterable, convert all the elements, then convert back
        if t is dict:
            return {k:cast_(v,to) for k,v in obj.items()}
        else:# t in iterables:
            return cast_([cast_(i,to) for i in obj],t)
    else: #otherwise, wrap around the exterior. do this manually for each type, unfortunately
        if to is list:
            return [obj]
        elif to is tuple:
            return (obj,)
        elif to is str:
            return f'{obj}'
        elif to is dict:
            return {obj:obj}
        elif to is set:
            return {obj}
        elif to is np.ndarray:
            return np.array(obj).astype(to)

# Cell
def pad(data : Union[np.ndarray,list],
          bits : Optional[int] = None,
          to : Union[int,float] = int) -> np.ndarray:
    '''
    Pads an array with zeros, up to a length of `bits`.
    '''
    if bits is None:
        bits=0
    else:
        bits=bits-len(data)
    x=[0 for i in range(bits)]+list(data)
    x=np.array(x).astype(to)
    return x

# Cell
def fillar(x : list,fillwith=np.NaN,mask=True):
    '''
    Turn uneven nested lists `x` into arrays `y` substituting
    missing entries using `fillwith` and optionally masking.
    '''
    length = max(map(len, x))
    y=np.array([xi+[fillwith]*(length-len(xi)) for xi in x])
    if mask:
        if np.isfinite(fillwith):
            y=np.ma.masked_equal(y,fillwith)
        else:
            y=np.ma.masked_invalid(y)
    return y

# Cell
def nbits(x : Union[int,float,list,np.ndarray]) -> int:
    '''
    Return the number of bits required to represent the input `x`.
    '''
    t=type(x)
    if (t is int) or (t is float):
        bits=np.ceil(np.log2(x+1)).astype(int) if x!=0 else 1
    elif (t is list) or (t is np.ndarray):
        bits=len(x)
    return bits

# Cell
def rint(x: Union[int,float,list,np.ndarray]) -> Union[int,np.ndarray]:
    '''
    Typecast rounding to np arrays.

    '''
    t=type(x)
    if (t is list) or (t is np.ndarray):
        return np.rint(x).astype(int)
    else:
        return round(x)

# Cell
class RNG:
    '''
    Globally stable random number generator. Initialized with fixed `seed`.
    Contains `normal` and `random` methods, each with an `absval` and `asint` argument,
    which convert to positive values and round to integers respectively.

    Example use:
        rng=RNG(seed=0)
        rng.normal(x=0,dx=1,shape=(2,2))
        rng.random(a=0,b=5,shape=(2,2),asint=True,absval=True)
    '''
    def __init__(self,seed : Optional[int] = 0):
        self.rng=np.random.default_rng(seed)

    def typecast(self,
                 y : Union[int,float],
                 absval : bool = False,
                 asint : bool = False) -> Union[int,float,np.ndarray]:
        if absval:
            y=abs(y)
        if asint:
            y=rint(y)
        return y

    def normal(self,
               x : Union[float,int] = 0,
               y : Union[float,int] = 0,
               shape : Optional[tuple] = None,
               absval : bool = False,
               asint : bool = False) -> Union[int,float,np.ndarray]:
        '''
        Draw from a Gaussian distribution with mean `x` and standard deviation `y`.
        If `shape` is not None, return a numpy array of draws.
        '''
        return self.typecast(y=self.rng.normal(loc=x,scale=y,size=shape),absval=absval,asint=asint)

    def random(self,
               x : Union[float,int] = 0,
               y : Union[float,int] = 0,
               shape : Optional[tuple] = None,
               absval : bool = False,
               asint : bool = False) -> Union[int,float,np.ndarray]:
        '''
        Draw from a uniform distribution in the interval [`x`,`y`].
        If `shape` is not None, return a numpy array of draws.
        '''
        return self.typecast((y-x)*self.rng.random(size=shape),absval=absval,asint=asint)

# Cell
def num2ar(x: Union[int,float],
            bits : Optional[int] = None,
            to : Union[int,float] = int) -> np.ndarray:
    '''
    Converts decimal number `x` to array `a` zero-padded with `bits`.
    '''
    bits=bits or nbits(x) #if None, give default
    form='0'+str(bits)+'b'
    binary=format(int(x),form)
    with warnings.catch_warnings(): #ignore numpy deprecation warning
        warnings.simplefilter("ignore")
        a=np.fromstring(binary,'u1')-ord('0')
    return cast(a,to)

# Cell
def ar2num(a : Union[list,np.ndarray],
            to : Union[int,float] = int):
    '''
    Converts array `a` to decimal number `x`.
    '''
    temp=str()
    a=np.array(a).astype(int)
    for c in a:
        temp+=str(c)
    x=int(temp,2)
    return cast(x,to)

# Cell
def ar2hex(a : Union[list,np.ndarray],
            bits : Optional[int] = None,
            prefix : bool = True) -> str:
    '''
    Converts binary array to hex string
    in:
        a (numpy array) : binary array to convert
    out:
        h (str) : hex conversion of a
    '''
    bits=bits or nbits(a)
    form='0'+str(int(np.log2(bits)))+'x'
    h=format(ar2num(a),form)
    if prefix:
        h='0x'+h
    return h

# Cell
def hex2ar(h : str,
            bits : Optional[int] = None,
            to : Union[int,float] = int) -> np.ndarray:
    '''
    Converts a hex string `h` into an array `a` padded with `bits` and elements of `astype`.
    '''
    x=int(h,16)
    a=num2ar(x,bits,to)
    return a

# Cell
def str2ar(s : str,
            to : Union[list,np.ndarray] = np.ndarray) -> Union[list,np.ndarray]:
    '''
    Converts an input string `s` into an array or list `a` as per `astype`.
    '''
    a=cast([int(i) for i in s],to)
    return a

# Cell
def ar2str(a : Union[list,np.ndarray], to : data = None) -> str:
    '''
    Converts an input array `a` into a string `s`.
    '''
    s=''.join([str(cast(i,to)) for i in a])
    return s

# Cell
def COPY(x : Union[int,float],
         to : Union[int,float] = int) -> Union[int,float]:
    '''
    Simply returns `x`.
    '''
    return cast(x,to)

def NOT(x : Union[int,float],
        to : Union[int,float] = int) -> Union[int,float]:
    '''
    Return conjugate of `x`.
    '''
    return cast(1.-x,to)

def AND(x : Union[int,float],
        y : Union[int,float],
        to : Union[int,float] = int) -> Union[int,float]:
    '''
    Return logical AND of `x` and `y`.
    '''
    return cast(x*y,to)

def OR(x : Union[int,float],
       y : Union[int,float],
       to : Union[int,float] = int) -> Union[int,float]:
    '''
    Return logical OR of `x` and `y`. See DeMorgan's Laws.
    '''
    return cast(x+y-x*y,to)

def Exclusive_OR(x : Union[int,float],
                 y : Union[int,float],
                 to : Union[int,float] = int) -> Union[int,float]:
    '''
    Return logical exclusive OR of `x` and `y`. See DeMorgan's Laws.
    '''
    return cast( OR( AND( x , NOT(y,to), to ) , AND ( NOT(x,to) , y, to), to ) , to)

def XOR(*args : Union[int,float,list,np.ndarray],
        to : Union[int,float] = int) -> Union[int,float]:
    '''
    Arbitrary input XOR using recursiveness.
    '''
    x=0.0
    for a in args:
        x=Exclusive_OR(x,a,to)
    return cast(x,to)

# Cell
def ar2gr(binary : Union[list,np.ndarray],
             to : Union[list,np.ndarray] = np.ndarray) -> Union[list,np.ndarray]:
    '''
    Converts an input binary array to graycode.
    '''
    binary = cast(binary,int)
    gray = []
    gray += [binary[0]]
    for i in range(1,len(binary)):
        gray += [XOR(binary[i - 1], binary[i])]
    return cast(cast(gray,int),to)

# Cell
def gr2ar(gray : Union[list,np.ndarray],
             to : Union[list,np.ndarray] = np.ndarray) -> Union[list,np.ndarray]:
    '''
    Converts a gray-code array into binary.
    '''
    binary = []
    binary += [gray[0]]
    for i in range(1, len(gray)):
        if (gray[i] == 0):
            binary += [binary[i - 1]]
        else:
            binary += [NOT(binary[i - 1])]
    return cast(cast(binary,int),to)


# Cell
def num2gr(x:int,to:data=None):
    '''
    Converts decimal number `x` to equivalent gray-code number.
    '''
    return int(ar2str(ar2gr(num2ar(x))),2)

# Cell
def convert(obj : Union[int,float,list,hex,str,np.ndarray],
            to : Union[int,float,list,hex,str,np.ndarray] = np.ndarray,
            bits : Optional[int] = None,
            astype : Union[int,float,list,np.ndarray] = int,
            gray : bool = False):
    '''
    Converts an input `obj` into an output of type `to`, padding with `bits`.
    Internally converts `obj` to np.ndarray with elements of dtype `astype`,
    before converting to the desired dtype `to`. If `gray`, first converts this
    binary array to gray-code. If input or output are `hex`, requires prefix of `0x`.

    Possible conversions:
        int -> float
        int -> str
        int -> list
        int -> array
        int -> hex

        str -> int
        str -> float
        str -> list
        str -> array
        str -> hex

        list -> arr
        list -> int
        list -> float
        list -> str
        list -> hex

        arr -> list
        arr -> int
        arr -> float
        arr -> str
        arr -> hex

        hex -> int
        hex -> float
        hex -> arr
        hex -> list
        hex -> str

    '''

    t=type(obj)
    #first convert to binary numpy array
    if (t is np.ndarray) or (t is list):
        x=obj
    elif (t is int) or (t is float):
        x=num2ar(obj,bits,astype)
    else:# t is str
        if obj[:2]=='0x': #obj is hex
            x=hex2ar(obj[2:],bits,astype)
        else:
            x=str2ar(obj)
    x=cast(pad(x,bits),astype)
    g=cast(ar2gr(x),astype)
    #convert
    if (to is np.ndarray):
        if gray:
            return g
        else:
            return x
    elif (to is list) or (to is set):
        if gray:
            return to(g)
        else:
            return to(x)
    elif (to is int) or (to is float) or (to is hex):
        if gray:
            return to(ar2num(g))
        else:
            return to(ar2num(x))
    else:# to is str
        if gray:
            return ar2str(g)
        else:
            return ar2str(x)